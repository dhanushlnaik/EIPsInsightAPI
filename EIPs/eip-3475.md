---
eip: 3475
<<<<<<< HEAD
title: Abstract Storage Bonds
description: Interface for creating tokenized obligations with abstract on-chain metadata storage
author: Yu Liu (@yuliu-debond), Varun Deshpande (@dr-chain), Cedric Ngakam (@drikssy), Dhruv Malik (@GrandGarcon), Samuel Gwlanold (@Edoumou), Toufic Batrice (@toufic0710)
discussions-to: https://ethereum-magicians.org/t/eip-3475-multiple-callable-bonds-standard/8691
status: Last Call
last-call-deadline: 2022-07-30
=======
title: Multiple Callable Bonds Standard
description: A standard interface for contract that manage multiple bonds. This standard will allow multiple LP token contract to store more information
author: Yu LIU (@yuliu-debond), Waroon D. (@dr-chain), Cedric Ngakam (@drikssy), Dhruv Malik (@GrandGarcon), Samuel Gwlanold (@Edoumou), Toufic Batrice (@toufic0710)
discussions-to: https://ethereum-magicians.org/t/eip-3475-multiple-callable-bonds-standard/8691
status: Review
>>>>>>> f5e51c8f2d6281b6e36564190b3085842b9f4703
type: Standards Track
category: ERC
created: 2021-04-05
---

<<<<<<< HEAD
## Abstract

This API standard allows the creation of tokenized obligations with abstract on-chain metadata storage. Issuing bonds with multiple redemption data cannot be achieved with existing token standards. This proposal enables each bond class ID to represent a new configurable token type and corresponding to each class, corresponding bond nonces to represent an issuing condition or any other form of data in uint256. Every single nonce of a bond class can have its metadata, supply, and other redemption conditions.

## Motivation


Current LP tokens are simple [EIP-20](./eip-20.md) tokens with no complex data structure. To allow more complex reward and redemption logic to be stored on-chain, we need a new token standard that can manage:

 - Multidimensional token ID.
 - Store on-chain metadata.
 - Non-specified and flexible storage.
 - Gas efficient.

This proposal allows the creation of any obligation with the same interface. It will enable any 3rd party wallet applications or exchanges to read these tokens' balance and redemption conditions. These bonds can also be batched as tradeable instruments. Those instruments can then be divided and exchanged in secondary markets.

Also, the significant reason behind the standard's name (abstract storage bond) is its ability to store all the specifications (metadata/values and transaction as defined in the following sections) without needing external storage.

The functions defined in this EIP provide a gas-efficient solution for creating, trading, and burning bonds. They offer more optimisation options for existing AMM solution.

The bonds can also be called in batch for issuance and can be divided and exchanged in a secondary market. The functions defined in this standard do operations on the serialized array, rather than storing them in struct mappings, resulting in significant savings of gas costs for storage and query. 

## Specification

**Definition**

Bank: an entity that issues, redeems, or burns bonds after getting the necessary amount of liquidity. Generally, a single entity with access to the pool.

**Functions**

```solidity
pragma solidity ^0.8.0;

/**
* transferFrom
* @param _from argument is the address of the bond holder whose balance is about to decrease.
* @param _to argument is the address of the bond recipient whose balance is about to increase.
* @param _transaction is the `Transaction[] calldata` (of type ['classId', 'nonceId', '_amountBonds']) structure defined in the rationale.
* @dev transferFrom MUST have the `isApprovedFor(_from, _to, _transaction[i].classId)` approval to transfer `_from` address to `_to` address for given classId (for all transaction in the array structure).
*/
// function transferFrom(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, 0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B, [[1, 42, 500000000]]);
// transfer from `_from` address, to `_to` address, `500000000` bonds of type class`1` and nonce `42`.
function transferFrom(address _from, address _to, Transaction[] calldata _transaction) external;

/**
* transferAllowanceFrom
* @dev allows the transfer of only those bond types and nonces being allotted to the _to address using allowance().
* @param _from is the address of the holder whose balance is about to decrease.
* @param _to is the address of the recipient whose balance is about to increase.
* @param _transaction is the `Transaction[] calldata` structure defined in the section `rationale` below.
* @dev transferAllowanceFrom MUST have the `allowance(_from, msg.sender, _transactions[i].classId, _transactions[i].nonceId)` 
* implemented inside (where `i` looping for all the transaction index) 
*/
// function transferAllowanceFrom(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, 0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B, [[1, 42, 500000000]]);
// transfer from `_from` address, to `_to` address, `500000000` bonds of type class`1` and nonce `42`.
function transferAllowanceFrom(address _from,address _to, Transaction[] calldata _transactions) public virtual override

/**
* issue 
* @dev allows issuing any number of bond types to an address.
* @dev it MUST be issued by a single entity (for instance, a role-based ownable contract that has integration with the liquidity pool of the deposited collateral by `_to` address).
* @param `_to` argument is the address to which the bond will be issued.
* @param `_transaction` is the `Transaction[] calldata` (ie array of issued bond class, bond nonce and amount of bonds to be issued).
* @dev transferAllowanceFrom MUST have the `allowance(_from, msg.sender, _transactions[i].classId, _transactions[i].nonceId)`
* implemented for all the transactions in the array.
*/
// example: issue(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef,[[0,5,1000]]);
// issues `1000` bonds with a class of `0` to address `0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef` with a nonce of `5`.
function issue(address _to, Transaction[] calldata _transaction) external; 

/**
* redeem
* @dev permits redemption of bond from an address.
* @dev the calling of this function needs to be restricted to the bond issuer contract.
* @param `_from` is the address from which the bond will be redeemed.
* @param `_transaction` is the `Transaction[] calldata` structure (i.e., array of tuples with the pairs of (class, nonce and amount) of the bonds that are to be redeemed). Further defined in the rationale section.
* @dev redeem function for a given class, and nonce category MUST BE done after certain conditions for maturity (can be end time, total active liquidity, etc.) are met. 
* @dev furthermore, it SHOULD ONLY be called by the bank or secondary market maker contract.
*/
// redeem(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, [[1,42,500000000]]);
// means “redeem from wallet address(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef), 500000000 of bond class1 and nonce 42.
function redeem(address _from, Transaction[] calldata _transaction) external; 

/**
* burn
* @dev permits nullifying of the bonds (or transferring given bonds to address(0)).
* @dev burn function for given class and nonce MUST BE called by only the controller contract.
* @param _from is the address of the holder whose bonds are about to burn.
* @param `_transaction` is the `Transaction[] calldata` structure (i.e., array of tuple with the pairs of (class, nonce and amount) of the bonds that are to be burned). further defined in the rationale.
* @dev redeem function for a given class, and nonce category MUST BE done only after certain conditions for maturity (can be end time, total active liquidity, etc). 
* @dev furthermore, it SHOULD ONLY be called by the bank or secondary market maker contract.
*/
// burnBond(0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B,[[1,42,500000000]]);
// means burning 500000000 bonds of class 1 nonce 42 owned by address 0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B.
function burn(address _from, Transaction[] calldata _transaction) external; 

/**
* approve
* @dev Allows `_spender` to withdraw from the msg.sender the bonds of `_amount` and type (classId and nonceId).
* @dev If this function is called again, it overwrites the current allowance with the amount.
* @dev `approve()` should only be callable by the bank, or the owner of the account.
* @param `_spender` argument is the address of the user who is approved to transfer the bonds.
* @param `_transaction` is the `Transaction[] calldata` structure (ie array of tuple with the pairs of (class,nonce, and amount) of the bonds that are to be approved to be spend by _spender). Further defined in the rationale section.
*/
// approve(0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B,[[0,1,30000]]);
// means owner of address 0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B is approved to manage 30000 bonds from class 0 and Nonce 1.
function approve(address _spender, Transaction[] calldata _transaction) external;

/**
* SetApprovalFor
* @dev enable or disable approval for a third party (“operator”) to manage all the Bonds in the given class of the caller’s bonds.
* @dev If this function is called again, it overwrites the current allowance with the amount.
* @dev `approve()` should only be callable by the bank or the owner of the account.
* @param `_operator` is the address to add to the set of authorized operators.
* @param `classId` is the class id of the bond.
* @param `_approved` is true if the operator is approved (based on the conditions provided), false meaning approval is revoked.
* @dev contract MUST define internal function regarding the conditions for setting approval and should be callable only by bank or owner.
*/
// setApprovalFor(0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B,0,true);
// means that address 0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B is authorized to transfer bonds from class 0 (across all nonces).
function setApprovalFor(address _operator, bool _approved) external returns(bool approved);

/**
* totalSupply
* @dev Here, total supply includes burned and redeemed supply.
* @param classId is the corresponding classId of the bond.
* @param nonceId is the nonce id of the given bond class.
* @return the supply of the bonds
*/
// totalSupply(0, 1);
// it finds the total supply of the bonds of classid 0 and bond nonce 1.
function totalSupply(uint256 classId, uint256 nonceId) external view returns (uint256);

/**
* redeemedSupply
* @dev Returns the redeemed supply of the bond in question.
* @param classId is the corresponding classId of the bond.
* @param nonceId is the nonce id of the given bond class.
* @return the supply of bonds redeemed.
*/
function redeemedSupply(uint256 classId, uint256 nonceId) external view returns (uint256);

/**
* activeSupply
* @dev Returns the active supply of the bond defined by (classId,NonceId).
* @param classId is the corresponding classId of the bond.
* @param nonceId is the nonce id of the given bond class.
* @return the non-redeemed, active supply. 
*/
function activeSupply(uint256 classId, uint256 nonceId) external view returns (uint256);

/**
* burnedSupply
* @dev Returns the burned supply of the bond in defined by (classId,NonceId).
* @param classId is the corresponding classId of the bond.
* @param nonceId is the nonce id of the given bond class.
* @return gets the supply of bonds for given classId and nonceId that is already burned.
*/
function burnedSupply(uint256 classId, uint256 nonceId) external view returns (uint256);

/**
* balanceOf
* @dev Returns the balance of the bonds (nonReferenced) of given classId and bond nonce held by the address `_account`.
* @param classId is the corresponding classId of the bond.
* @param nonceId is the nonce id of the given bond class.
* @param _account address of the owner whose balance is to be determined.
* @dev this also consists of bonds that are redeemed.
*/
function balanceOf(address _account, uint256 classId, uint256 nonceId) external view returns (uint256);

/**
* classMetadata
* @dev Returns the JSON metadata of the classes.
* @dev The metadata SHOULD follow a set of structure explained later in the metadata.md
* @param metadataId is the index-id given bond class information.
* @return the JSON metadata of the nonces. — e.g. `[title, type, description]`.
*/
function classMetadata(uint256 metadataId) external view returns ( Metadata memory);

/**
* nonceMetadata 
* @dev Returns the JSON metadata of the nonces.
* @dev The metadata SHOULD follow a set of structure explained later in metadata.md
* @param classId is the corresponding classId of the bond.
* @param nonceId is the nonce id of the given bond class.
* @param metadataId is the index of the JSON storage for given metadata information. more is defined in metadata.md.
* @returns the JSON metadata of the nonces. — e.g. `[title, type, description]`.
*/
function nonceMetadata(uint256 classId, uint256 metadataId) external view returns ( Metadata memory);

/**
* classValues
* @dev allows anyone to read the values (stored in struct Values for different class) for given bond class `classId`.
* @dev the values SHOULD follow a set of structures as explained in metadata along with correct mapping corresponding to the given metadata structure
* @param classId is the corresponding classId of the bond.
* @param metadataId is the index of the JSON storage for given metadata information of all values of given metadata. more is defined in metadata.md.
* @returns the Values of the class metadata. — e.g. `[string, uint, address]`.
*/
function classValues(uint256 classId, uint256 metadataId) external view returns ( Values memory);

/**
* nonceValues
* @dev allows anyone to read the values (stored in struct Values for different class) for given bond (`nonceId`,`classId`).
* @dev the values SHOULD follow a set of structures explained in metadata along with correct mapping corresponding to the given metadata structure
* @param classId is the corresponding classId of the bond.
* @param metadataId is the index of the JSON storage for given metadata information of all values of given metadata. More is defined in metadata.md.
* @returns the Values of the class metadata. — e.g. `[string, uint, address]`.
*/
function nonceValues(uint256 classId, uint256 nonceId, uint256 metadataId) external view returns ( Values memory);

/**
* getProgress
* @dev Returns the parameters to determine the current status of bonds maturity.
* @dev the conditions of redemption SHOULD be defined with one or several internal functions. 
* @param classId is the corresponding classId of the bond.
* @param nonceId is the nonceId of the given bond class . 
* @returns progressAchieved defines metric (either %, time, etc.) that defines the current status of the bond.
* @returns progressRemaining defines the metric that defines the remaining time/ remaining progress. 
*/
function getProgress(uint256 classId, uint256 nonceId) external view returns (uint256 progressAchieved, uint256 progressRemaining);

/** 
* allowance
* @dev Authorizes to set the allowance for given `_spender` by `_owner` for all bonds identified by (classId, nonceId).
* @param _owner address of the owner of bond(and also msg.sender).
* @param _spender is the address authorized to spend the bonds held by _owner of info (classId, nonceId).
* @param classId is the corresponding classId of the bond.
* @param nonceId is the nonceId of the given bond class. 
* @notice Returns the _amount which spender is still allowed to withdraw from _owner.
*/
function allowance(address _owner, address _spender, uint256 classId, uint256 nonceId) external view returns (uint256);

/** 
* isApprovedFor
* @dev returns true if address _operator is approved for managing the account’s bonds class.
* @notice Queries the approval status of an operator for a given owner.
* @dev _owner is the owner of bonds. 
* @dev _operator is the EOA/ contract, whose status for approval on bond class for this approval is checked.
* @returns “true” if the operator is approved, “false” if not.
*/
function isApprovedFor(address _owner, address _operator) external view returns (bool);
```

**Events**

```solidity
/** 
* Issue
* @notice Issue MUST trigger when Bonds are issued. This SHOULD not include zero value Issuing.
* @dev This SHOULD not include zero value Issuing.
* @dev Issue MUST be triggered when the operator (i.e Bank address) contract issues bonds to the given entity.
*/
// emit Issue(_operator, 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef,[['0','14','500']]); 
// issue by address(operator) 500 DBIT-USD Bond(nonce14,class 0) to address 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef.
event Issue(address indexed _operator, address indexed _to, Transaction[] _transaction); 

/** 
* Redeem
* @notice Redeem MUST trigger when Bonds are redeemed. This SHOULD not include zero value redemption.
*/
//emit Redeem(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef,0x492Af743654549b12b1B807a9E0e8F397E44236E,[[1,14,500]]);
//5000 bonds of class 1, nonce 14 owned by address 0x492Af743654549b12b1B807a9E0e8F397E44236E are being redeemed by 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef.
event Redeem(address indexed _operator, address indexed _from, uint256 classId, uint256 nonceId, uint256 _amount);

/** 
* Burn.
* @dev `Burn` MUST trigger when the bonds are being redeemed via staking (or being invalidated) by the bank contract.
* @dev `Burn` MUST trigger when Bonds are burned. This SHOULD not include zero value burning.
*/
// emit Burn(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef,0x492Af743654549b12b1B807a9E0e8F397E44236E,[[1,14,500]]);
// 5000 bonds of owner 0x492Af743654549b12b1B807a9E0e8F397E44236E of type (class 1, nonce 14) are burned by operator 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef.
event Burn(address indexed _operator, address indexed _from, Transaction[] _transaction);

/** 
* Transfer
* @dev its emitted when bond is transferred by address(operator) from owner address(_from) to address(_to) with the bonds transferred, whose params are defined by _transaction struct array. 
* @dev Transfer MUST trigger when Bonds are transferred. This SHOULD not include zero value transfers.
* @dev Transfer event with the _from `0x0` MUST not create this event(use `event Issued` instead). 
*/
// emit Transfer(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, 0x492Af743654549b12b1B807a9E0e8F397E44236E, address _to, [[1,4,500]]);
// transfer by address(_operator) amount 500 DBIT-USD bonds with (Class 1 and Nonce 14) from 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, to address(_to).
event Transfer(address indexed _operator, address indexed _from, address indexed _to, Transaction[] _transaction);

/**
* ApprovalFor
* @dev its emitted when address(_owner) gives approval to address(_operator) to transfer his bonds.
* @notice Approval MUST trigger when bond-holders are approving an _operator. This SHOULD not include zero value approval. 
*/
// emit ApprovalFor(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, 0x492Af743654549b12b1B807a9E0e8F397E44236E);
// this means 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef gives 0x492Af743654549b12b1B807a9E0e8F397E44236E access permission for transfer of its bonds.
event ApprovalFor(address indexed _owner, address indexed _operator, bool _approved);
```

**Metadata**:
The metadata of a bond class or nonce is stored as an array of JSON objects, represented by the following types. 

**NOTE: all of the metadata schemas are referenced from [here](../assets/eip-3475/Metadata.md)**

### 1. Description:
This defines the additional information about the nature of data being stored in the nonce/class metadata structures. They are defined using the structured explained [here](../assets/eip-3475/Metadata.md#1-description-metadata). this will then be used by the frontend of the respective entities participating in the bond markets to interpret the data which is compliant with their jurisdiction. 

### 2. Nonce:

The key value for indexing the information is the 'class' field. Following are the rules:

- The title can be any alpha numeric type that is differentiated by the description of metadata (although it can be dependent on certain jurisdictions).
- The title SHOULD not be EMPTY.

Some specific examples of metadata can be the localization of bonds, jurisdiction details etc., and they can be found in the metadata description.

### 3. Class metadata:

This structure defines the details of the class information (symbol, risk information, etc.). the example is explained [here](../assets/eip-3475/Metadata.md) in the class metadata section.

### 4. Decoding data:

First, the functions for analyzing the metadata (i.e `ClassMetadata` and `NonceMetadata`) are to be used by corresponding frontend to decode the information of the bond. 

This is done via overriding the function interface for functions `classValues` and `nonceValues` by defining the key (which SHOULD be an index) to read the corresponding information stored as a JSON object. 

```JSON
{
"title": "symbol",
"_type": "string",
"description": "Lorem ipsum..."
"values": ["Class Name 1","Class Name 2","DBIT Fix 6M"],
}
```

e.g. in the above example, to get the `symbol` of the given class id, we can use the class id as a key to get the `symbol` value in the values, which then can be used for fetching the detail for instance.


## Rationale

**Metadata structure**: Instead of utilizing a mapping from address, the bond's metadata like the time of redemption, redemption conditions, and interest rate can be stored in the bond class and nonce structures. Classes represent the different bond types, and nonces represent the various period of issuances. Nonces under the same class share the same metadata. Meanwhile, nonces are non-fungible. Each nonce can store a different set of metadata. Thus, upon transfer of a bond, all the metadata will be transferred to the new owner of the bond.

```solidity
 struct Values{
 string stringValue;
 uint uintValue;
 address addressValue;
 bool boolValue;
 }
```

```solidity
 struct Metadata {
 string title;
 string _type;
 string description;
 }
```

**Batch function:**

 This EIP supports batch operations such as a batch transactions. It allows the user to transfer different bonds along with their metadata to a new address instantaneously in a single txn. And after execution, the new owner holds the right to reclaim the face value of each of the bonds. This mechanism helps in the "packaging" of bonds which is helpful in use cases like trades on a secondary market.

```solidity
 struct Transaction {
 uint256 classId;
 uint256 nonceId;
 uint256 _amount;
 }
```

Where: 
The `classId` is the class id of the bond.

The `nonceId` is the nonce id of the given bond class. This param is for distinctions of the issuing conditions of the bond.

The `_amount` is the amount of the bond for which the spender is approved.


**AMM optimization**: One of the most obvious use cases of this EIP is the multilayered pool. The early version of AMM uses a separate smart contract and an [EIP-20](./eip-20.md) LP token to manage a pair. By doing so, the overall liquidity inside of one pool is significantly reduced and thus generates unnecessary gas spent and slippage. Using this EIP standard, one can build a big liquidity pool with all the pairs inside (thanks to the presence of the data structures consisting of the liquidity corresponding to the given class and nonce of bonds). Thus by knowing the class and nonce of the bonds, the liquidity can be represented as the percentage of a given token pair for the owner of the bond in the given pool. Effectively, the [EIP-20](./eip-20.md) LP token (defined by a unique smart contract in the pool factory contract) is aggregated into a single bond and consolidated into a single pool.

## Backwards Compatibility

Any contract that inherits the interface of this EIP is compatible. Also, it is valid for both the issuer and receiver of the bonds, and the client EOA needs this standard interface.

However, any existing [EIP-20](./eip-20.md) token contract can issue its bonds by delegating the minting role to a bank contract with the interface of this standard built-in. Check out our reference implementation for the correct interface definition.

To ensure the reading of transactions, "Issue", "Redeem", "Burn" and "Transfer", Events cited above MUST be emitted when such transaction is passed.

**Note that the this standard interface is also compatible with [EIP-20](./eip-20.md) and [EIP-721](./eip-721.md) interface.**

However, creating a separate bank contract is recommended for reading the bonds and future upgrade needs.

Acceptable collateral can be in the form of [EIP-20](./eip-20.md) tokens, [EIP-721](./eip-721.md) tokens, or other bonds represented by the standard.Thus bonds can now represent a collection of collaterals (of the same type) of all fungible/non-fungible or semi-fungible tokens.

## Test Cases

Testcase for the minimal reference implementation is available [here](../assets/eip-3475/ERC3475.test.ts). Developers need to run this script with truffle dependency in the npm package.

## Reference Implementation

[Reference Interface](../assets/eip-3475/IERC3475.sol).
  - This demonstration shows only minimalist implementation.

[Debond-EIP-3475](../assets/eip-3475/Debond-ERC3475.sol) 
  - Real use case consisting of more sophisticated logic like:
    - Different classes of bonds (fixed/floating rate bonds).
    - Redemption conditions.

## Security Considerations

- The `function setApprovalFor()` gives the operator role in this standard. It has all the permissions to transfer, burn and redeem bonds by default.
- If the owner wants to give a one-time allocation to an address, he should call the `function approve()` giving the `Transaction[]` allocated. 
- The `function issue()` can only be called by the bank contract (what we call issuer in this EIP).

## Copyright
=======


## Abstract

This API standard allows for the creation of any number of bonds type in a single contract. Existing LP token standards like [ERC-20](./eip-20.md) require deployment of separate factory and token contracts per token type. The need of issuing bonds with multiple redemption data can’t be achieved with existing token standards. ERC-3475 Multiple Callable Bonds Standard allows for each bond class ID to represent a new configurable token type, and for each bond nonce to represent an issuing date or any other forms of data in uint256. Every single nonce of a bond class may have its own metadata, supply and other redemption conditions.

## Motivation

Current LP token is a simple ERC-20 token, which has not much complicity in data structure. To allow more complex reward and redemption logic to be built, we need a new LP token standard that can manage multiple bonds, stores much more data and gas efficient. ERC-3475 standard interface allows any tokens on solidity compatible block chains to create its own bond. These bonds with the same interface standard can be exchanged in secondary market. And it allows any 3rd party wallet applications or exchanges to read the balance and the redemption conditions of these tokens. ERC-3475 bonds can also be packed into separate packages. Those packages can in their turn be divided and exchanged in a secondary market.

New functions built in ERC-3475 Multiple Callable Bonds Standard, will allow the users to economize their gas fee spend. Trading and burning of ERC-3475 Bonds will also multiply tokens market cap, helping it to recover from recession period. Existing structures, such as AMM exchanges or lending platform can be updated to recognize ERC-3475 Bonds.



## Specification

**TransferFrom**

`transferFrom(address from, address to, uint256 classId, uint256 nonceId, uint256 amount)` allows the transfer of any number of bond types from an address to another.

The`"_from"` argument is the address of the holder whose balance about to decrees.

The `"_to"` argument is the address of the recipient whose balance is about to increased.

The `"class"` is the bond class, the first bond class created will be 0, and so on.

The `"nonce"` is a nonce of the given bond class. This param is for distinctions of the issuing conditions of the bond.

The `"_amount"` is the amount of the bond, that will be transferred from `"_from"`address to `"_to"` address.

e.g.

```
transferFrom(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef,0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B, 1, 42, 500000000);
```

This example shows the transfer from `_from` address, to `\_to` address, `500000000` of bond class`1` nonce `42`


**Issue**

`issue(address to, uint256 classId, uint256 nonceId, uint256 amount)` allows issuing any number of bond types to an address.

The calling of this function needs to be restricted to bond issuer contract.

The `"to"` argument is the address to which the bond will be issued.

The `"classId"` is the classId of the bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonceId of the given bond class. This param is for distinctions of the issuing conditions of the bond.

The `"_amount"` is the amount of the bond, that "to" address will receive.

e.g.

```
issueBond(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, 0, 5, 1000);
```

This example shows the issuing to wallet address 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, 1000 of bond classId 0 and nonceId 5.



**Redeem**


`redeem(address from, uint256 classId, uint256 nonceId, uint256 amount)` redemption of any number of bond types from an address.

The calling of this function needs to be restricted to bond issuer contract.

The `"_from"` is the address from which the bond will be redeemed.

The `"classId"` is the class nonce of bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonce of the given bond class. This param is for distinctions of the issuing conditions of the bond.

The `"_amount"` is the amount of the bond, that `"_from"` address will redeem.

e.g.

```
redeem(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, 1, 42, 500000000);
```

those input mean “redeem from wallet address(0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef), 500000000 of bond class1 nonce 42


**Burn**

`burn(address from, uint256 classId, uint256 nonceId, uint256 amount)` allows the transfer of any number of bond types from an address to another.

The`"_from"` argument is the address of the holder whose balance about to decrees.

The `"class"` is the list of class nonce of bond, the first bond class created will be 0, and so on.

The `"nonce"` is the list of nonce of the given bond class. This param is for distinctions of the issuing conditions of the bond.

The `"_amount"` is the list of amount of the bond, that will be transferred from `"_from"`address to `"_to"` address.

e.g.

```
burnBond(0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B, [1,2,4],[42,61,25], [500000000,60000000,150000000]);
```


**Approve**

`approve(address spender, uint256 classId, uint256 nonceId, uint256 amount)` Allows spender to withdraw from your account multiple times, up to the amount.

If this function is called again it overwrites the current allowance with amount.

The`"spender"` is the address the caller approve for his bonds

The `"classId"` is the classId nonce of bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonceId of the given bond class. This param is for distinctions of the issuing conditions of the bond.

The `"_amount"` is the amount of the bond that the spender is approved for.

e.g.

```
approve(0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B, 0, 1, 30000);
```
mean 0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B is approved to manage 30000 bonds from class 0 and Nonce 1




**SetApprovalFor**

`setApprovalFor(address operator, uint256 classId, bool approved)` Enable or disable approval for a third party ("operator") to manage Bond class of the caller's bonds.

The`"operator"` is the Address to add to the set of authorized operators

The `"classId"` is the classId nonce of bond, the first bond class created will be 0, and so on.

The `"_approved"` True if the operator is approved, false to revoke approval

e.g.

```
setApprovalFor(0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B, 0, true);
```
mean 0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B is approved to transfer bonds from class 0


**BatchApprove**

`batchApprove(address spender, uint256[] calldata classIds, uint256[] calldata nonceIds, uint256[] calldata amounts)` Allows spender to withdraw from your account multiple times, up to the amount.

If this function is called again it overwrites the current allowance with amount.

The`"spender"` is the address the caller approve for his bonds

The `"classIds"` is the list of classIds of bond.

The `"nonceIds"` is the list of nonceIds of the given bond class.

The `"_amounts"` is the list of amounts of the bond that the spender is approved for.

e.g.

```
batchApprove(0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B, [0,1,2], [30,42,3] , [30000, 50000, 2000]);
```
mean 0x82a55a613429Aeb3D01fbE6841bE1AcA4fFD5b2B is approved to manage : 
- 30000 bonds from class 0 and Nonce 30
- 50000 bonds from class 1 and Nonce 42
- 2000 bonds from class 2 and Nonce 3


**TotalSupply**

`totalSupply(uint256 classId, uint256 nonceId)` allows anyone to read the total supply of a given bond's class and nonce, this includes burned and redeemed Supply 

The `"classId"` is the class nonce of bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonce of the bond. This param is for distinctions of the issuing conditions of the bond.

Returns the total supply of the bond in question. — e.g. `"5821200000000"`.

```
function totalSupply(uint256 class, uint256 nonce) external view returns (uint256);
```

**ActiveSupply**

`activeSupply(uint256 classId, uint256 nonceId)` allows anyone to read the non-burned and non-redeemed Supply of a given class nonce and bond nonce.

The `"classId"` is the class nonce of bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonce of the bond. This param is for distinctions of the issuing conditions of the bond.

Returns the active supply of the bond in question. — e.g. `"5821200000000"`.

```
function activeSupply( uint256 class, uint256 nonce) external view returns (uint256);
```

**BurnedSupply**

`burnedSupply(uint256 classId, uint256 nonceId)` allows anyone to read the burned Supply of a given class and bond nonce.

The `"classId"` is the class nonce of bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonce of the bond. This param is for distinctions of the issuing conditions of the bond.

Returns the active supply of the bond in question. — e.g. `"612300000000"`.

```
function burnedSupply( uint256 class, uint256 nonce) external view returns (uint256);
```

**RedeemedSupply**

`redeemedSupply(uint256 classId, uint256 nonceId)` allows anyone to read the redeemed Supply of a given class and bond nonce.

The `"classId"` is the class nonce of bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonce of the bond. This param is for distinctions of the issuing conditions of the bond.

Returns the redeemed supply of the bond in question. — e.g. `"612300000000"`.

```
function redeemedSupply( uint256 class, uint256 nonce) external view returns (uint256);
```

**BalanceOf**

`balanceOf(address account, uint256 classId, uint256 nonceId)` allows anyone to read the remaining balance of an address. This will only return the balance of a single bond class and bond class nonce.

The `"account"` is the address of the token holder.

The `"classId"` is the class nonce of bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonce of the bond. This param is for distinctions of the issuing conditions of the bond.

Returns the balance of the giving bond class and bond nonce. — e.g. `"571300000000"`.

```
function balanceOf(address account, uint256 class, uint256 nonce) external view returns (uint256);
```

**Symbol**

`symbol(uint256 classId)` allows anyone to read the symbol of a bond class.

The `"class"` is the class nonce of bond, the first bond class created will be 0, and so on.

Returns the symbol string of the bond class. — e.g. bond symbol=`"DEBIT-BUSD bond"`.***DEBIT as the first half of the bond symbol represents the settlement token of the bond. BUSD as the second half of the bond symbol represents the token used for the perches of this bond. If the bond have more than one settlement token or buying token, the symbol should be* `"Token1,Token2-Token3,Token4 bond"`

```
function getBondSymbol(uint256 class) external view returns (uint256);
```

**ClassInfos**

`classInfos(uint256 classId)` allows anyone to read the information of a bond class.

The `"class"` is the class nonce of bond, the first bond class created will be 0, and so on.

Returns a list of uint256 parameters of a bond class. — e.g. `["1615584000",(2nd uint256)...]`.*** Every bond contract can have their own list.*

```
function classInfos(uint256 classId) external view returns (uint256[] memory);
```

**ClassInfoDescription**

`classInfoDescription(uint256 classInfo)` allows anyone to read the information description of a class info given.

The `"classInfo"` is the class info.

Returns the class information description of the class info key. *Every bond contract can have their own list of info description.*

```
classInfoDescription(uint256 classInfo) external view returns (string memory);
```


**NonceInfos**

`nonceInfos(uint256 classId, uint256 nonceId)` allows anyone to read the information of a bond class' nonce.

The `"class"` is the class nonce of bond, the first bond class created will be 0, and so on.

The `"nonce"` is the nonce of the bond. This param is for distinctions of the issuing conditions of the bond.

Returns a list of uint256 parameters of a bond nonce. — e.g. `["1615584000",(2nd uint256)...]`.*** Every bond contract can have their own list. But the first uint256 in the list MUST be the UTC time code of the issuing time.*

```
function nonceInfos(uint256 classId, uint256 nonceId) external view returns (uint256[] memory);
```

**NonceInfoDescription**

`nonceInfoDescription(uint256 nonceInfo)` allows anyone to read the information description of a nonce info given.

The `"nonceInfo"` is the nonce info

Returns the nonce information description of the nonce info key. *Every bond contract can have their own list of info description.*

```
nonceInfoDescription(uint256 nonceInfo) external view returns (string memory);
```

**IsRedeemable()**

`isRedeemable(uint256 classId, uint256 nonceId)` allows anyone to check if a bond is redeemable.*** the conditions of redemption can be speechified with one or several internal functions.*

The `"classId"` is the class nonce of bond, the first bond class created will be 0, and so on.

The `"nonceId"` is the nonce of the bond. This param is for distinctions of the issuing conditions of the bond.

Returns `"true"` if the cited bond is redeemable. and `"false"`if is not.

```
function bondIsRedeemable(uint256 class, uint256 nonce) external view returns (bool);
```


**IsApprovedFor**

`isApprovedFor(address owner, address operator, uint256 classId)` returns if ("operator") is approved to manage account's Bonds class.

The`"_owner"` The owner of the tokens

The`"_operator"` Address of authorized operator

The `"class"` is the bond class, the first bond class created will be 0, and so on.

```
isApprovedFor(address owner, address operator, uint256 classId) external view returns (bool);
```

### EVENT

`"Issue"` MUST trigger when Bonds are issued. This SHOULD not include zero value Issuing.


e.g. 

`"issue by address(operator) 500 DEBIT-USD Bond(Nonce14) to 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef"`

```
event Issue(address indexed _operator, address indexed _to, uint256 classId, uint256 nonceId, uint256 amount); 
```

`"Redeem"` MUST trigger when Bonds are redeemed. This SHOULD not include zero value redemption.

e.g. 

`"redeem by address(_operator) 500 DEBIT-USD Bond(Nonce14) to 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef"`

```
event Redeem(address indexed _operator, address indexed _from, uint256 classId, uint256 nonceId, uint256 amount);
```

`"Burn"` MUST trigger when Bonds are burned. This SHOULD not include zero value burning.

e.g. 

`"burn by address(_operator) 500 DEBIT-USD Bond(Nonce14) from 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef"`

```
event Burn(address indexed _operator, address indexed _from, uint256 classId, uint256 nonceId, uint256 amount);
```

`"Transfer"` MUST trigger when Bonds are transferred. This SHOULD not include zero value transfers. Transfer event with the `_from` `0x0` MUST not create this event(Use`"event Issued" `instead ). Transfer event with the `_to` `0x0` MUST not create this event(Use`"event Redeemed" `when redemption, and `"event Burned" `when burning).

e.g.

`"transfer by address(_operator) 500 DEBIT-USD Bond(Nonce14) from 0x2d03B6C79B75eE7aB35298878D05fe36DC1fE8Ef, to address(_to)"`

```
event Transfer(address indexed _operator, address indexed _from, address indexed _to, uint256 classId, uint256 nonceId, uint256 amount);
```

## Rationale

**Metadata structure**: Instead of utilizing a mapping from address, the bond's metadata like the time of redemption, redemption conditions, and interest rate can be stored in the bond class and nonce structures. Classes represent the different bond types, and nonces represent the various period of issuances. Nonces under the same class share the same metadata. Meanwhile, nonces are non-fungible. Each nonce can store a different set of metadata. Thus, upon transfer of a bond, all the metadata will be transferred to the new owner of the bond.

**Batch function**: ERC 3475 supports batch functions, such as batch transactions. It allows the user to transfer different bonds with different metadata to a new address at a time. This mechanism helps in the "packaging" of bonds. When a package of bonds trades on a secondary market, the new owner holds the right to reclaim the face value of each of the bonds.

**AMM optimization**: One of the most obvious use cases of ERC 3475 is the multilayered pool. The early version of AMM uses a separate smart contract and an ERC 20 LP token to manage a pair. By doing so, the overall liquidity inside of one pool is significantly reduced and thus generates unnecessary gas spent and slippage. Using ERC 3475, one can build a big liquidity pool with all the pairs inside. Then, with class and nonce, represent what percentage of a given token this address holds. Effectively, the ERC20 LP token is converted, in this case, to ERC 3475 (Multiple Callable Bonds) token.


## Backwards Compatibility

ERC-3475 contract is not compatible with contracts that don't have an ERC-3475 interface built in. This requires the existing contract to upgrade with ERC-3475 interface. The receiving of ERC-3475 Bond need the implementation of ERC-3475 interface in the receiver contract.

However any existing ERC-20 token contract can issue their ERC-3475 bond, by giving the minting role to a bank contract with ERC-3475 interface built in. The implementation of This can be found in our Use Cases.

To ensure the reading of transactions, `"Issued"` ,`"Redeemed"` ,`"Burned"` ,`"Transfer"`, Events cited above MUST be emitted when such transaction is passed. 

***Note that the ERC 3475 interface is also compatible with ERC-20 and [ERC-721](./eip-721.md) interface .*** But the creation of a separated bank contract is recommended for reading and future upgrade needs and .

The issuing of ERC-3475 bonds is not limited to ERC-20 token. Standard like ERC-721 nonfungible token can also issue their bond with the help of ERC-3475 interface. 

Any ERC3475 bond or any hybrid of ERC-20 and ERC-721 contract can be used as the collateral for another ERC-3475 bond. This allows the market to create bond represent no longer a single type of ERC-20 token. Bond can now represent a collection of collaterals in ERC-20 token, ERC-721 nonfungible token and ERC-3475 Multiple callable bonds...

## Reference Implementation

[ERC-3475 Reference Implementation](../assets/eip-3475/ERC3475.sol)

**This demonstration show only a simple application of ERC-3475 Multiple Callable Bonds Standard. Developers can build much sophisticated logic with this interface. No function used in the example serves as a guide-line.

## Security Considerations

There are no known security considerations for this EIP. More security considerations will be added after the authoring/feedback process of this EIP.

## Copyright Waiver
>>>>>>> f5e51c8f2d6281b6e36564190b3085842b9f4703

Copyright and related rights waived via [CC0](../LICENSE.md).
